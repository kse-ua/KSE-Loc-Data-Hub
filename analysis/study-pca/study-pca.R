# PCA study

rm(list = ls(all.names = TRUE)) # Clear the memory of variables from previous run. This is not called by knitr, because it's above the first chunk.
cat("\014") # Clear the console

# ---- load-packages -----------------------------------------------------------
# Choose to be greedy: load only what's needed
# Three ways, from least (1) to most(3) greedy:
# -- 1.Attach these packages so their functions don't need to be qualified: 
# http://r-pkgs.had.co.nz/namespace.html#search-path
library(ggplot2)   # graphs
library(forcats)   # factors
library(stringr)   # strings
library(lubridate) # dates
library(labelled)  # labels
library(dplyr)     # data wrangling
library(tidyr)     # data wrangling
# -- 2.Import only certain functions of a package into the search path.
import::from("magrittr", "%>%")
# -- 3. Verify these packages are available on the machine, but their functions need to be qualified
requireNamespace("readr"    )# data import/export
requireNamespace("readxl"   )# data import/export
requireNamespace("janitor"  )# tidy data
requireNamespace("testit"   )# For asserting conditions meet expected patterns.

pacman::p_load(tidyr,dplyr, ggplot2)
library(tidyverse)
library(readr)
library(readxl)
library(survey)
library(fastDummies)
library(gt)

# ---- load-sources ------------------------------------------------------------
base::source("./scripts/common-functions.R")             # basics
base::source("./scripts/graphing/graph-presets.R")       # font size, colors etc
base::source("./scripts/operational-functions.R")        # quick specific functions
base::source("./scripts/binary-categorical-functions.R") # graphing and modeling
# base::source("./analysis/open-budget/custom-model-functions.R") # plots
# ---- declare-globals ---------------------------------------------------------
# printed figures will go here:
prints_folder <- paste0("./analysis/study-pca/prints")
if (!fs::dir_exists(prints_folder)) { fs::dir_create(prints_folder) }

data_cache_folder <- prints_folder # to sink modeling steps

income_vars0 <- c(
   "income_total_2021"            = "Total revenue amount" # sum of all tax codes     
   # Total revenue can be broken into (1) that generated by the hromada (income_own)
   # and (2) that provided by the central government (income_transfert)
  ,"income_transfert_2021"        = "Revenue from transferts"                                                  
  ,"income_own_2021"              = "Revenue from OWN sources"# = income_total - income_transfert   
  # in turn, "income_own" can be broken down into components: 
  ,"income_pdfo_2021"             = "Own: income tax"                                                 
  ,"income_military_2021"         = "Own: military salaries"                           
  ,"income_unified_tax_2021"      = "Own: unified tax"                                                
  ,"income_property_tax_2021"     = "Own: property tax"                                               
  ,"income_excise_duty_2021"      = "Own: excise duty"                                                
  ,"income_other_2021"            = "Own: other sources" # income_own - sum(military,pdfo,unified,property,excise)                                                
)

# ---- declare-functions -------------------------------------------------------
'%ni%' <- Negate(`%in%`)

# ---- load-data ---------------------------------------------------------------
# the product of ./manipulation/ellis-survey.R # Resilience survey, collected in Oct-Nov 20222
ds_survey <- readxl::read_excel("./data-private/derived/survey_hromadas_clean.xlsx")

# the product of ./manipulation/ellis-general.R
ds_general <- readr::read_csv("./data-private/derived/full_dataset.csv")

# ls_fin <- readr::read_rds("./data-private/derived/ellis-budget-alt.rds")
# ds_budget <- ls_fin$budget$Data
# ds_budget_meta <- ls_fin$budget$Metadata
# ds_taxes <- ls_fin$taxes$Data
# ds_taxes_meta <- ls_fin$taxes$Metadata

# ---- tweak-data ---------
ds_general %>% glimpse()
# looks_fishy <- 
#   ds_general %>% 
#   filter(own_income_prop > 1 | own_income_prop < 0) %>%  # how can they be outside of this window?
#   pull(hromada_code)


ds0 <- 
  ds_general %>% 
  select(hromada_code, any_of(names(income_vars0)))
ds0 %>% glimpse()
# shorten the names of columns for ease of operations:
names(ds0) <- str_remove(names(ds0),"^income_") %>% 
  str_remove("_2021$") %>% str_remove("_tax$")  %>% str_remove("_duty$")
ds0 %>% glimpse()

# Test 1: Total = Own + Transfert
ds0 %>% 
  mutate(
    test1 = round(total) == round((transfert + own))
  ) %>% 
  filter(!test1)
# should return empty set if assumption holds

# ---- tweak-data-1 --------------------------

ds1 <- 
  ds0 %>% 
  mutate(
    # during computation in ./manipulation/ellis-budget-2020-2022.R, the formula
    # for `income_own` included `military_tax`, therefore, to isolate it : 
    pdfo = pdfo - military # now `own` means `income tax minus military`
  ) %>% 
  # we sum the income from the named taxes to verify the logic of break down
  rowwise() %>%
  mutate(
    itemized = sum( c_across(
      c("pdfo", "military", "unified", "property", "excise")
    ), na.rm = T)
  ) %>%
  ungroup() %>%
  # now we can compute the left-over from the own revenue after itemized are deducted
  mutate(
    other = own - itemized # all other revenue from taxes not mentioned by name
  ) %>% 
  glimpse()




# ----- tweak-data-2 ----------------------------

# itendify and control for suspicious data points
# Sum of itemized revenues cannot be greater than OWN
# We expect from data that the amount of `income_own` includes
# revenue from all revenue streams we have identified by name:
# (pdfo, military, unified, property, excise), therefore, the sum of these
# identified revenue streams (itemized) shoul NOT exceed its total (own)

with_negative_other <- ds1 %>% filter(other<0) %>% pull(hromada_code) %>% unique()

# those with own income not adding up
ds1 %>%
  filter(other < 0) %>%                 # same as below
  # filter(hromada_code %in% with_negative_other) %>% # same as above
  left_join(
    ds_general %>% select(hromada_code, hromada_name, oblast_name)
  ) %>% 
  relocate(hromada_code, hromada_name, oblast_name, other, itemized,own, total) %>%
  select(1:7)

# those with negative income from military salaries
ds1 %>%
  filter(military < 0) %>%
  left_join(
    ds_general %>% select(hromada_code, hromada_name, oblast_name)
  ) %>%
  relocate(hromada_code, hromada_name, oblast_name, military,own,transfert, total) %>%
  select(1:7)


ds2 <-
  ds1 %>%
  # 1) remove suspicious data points
  filter(!hromada_code %in% with_negative_other) %>%
  # 2) address negative numbers
  mutate(
    military  = case_when(
      # military <= 0 ~ 0, TRUE ~ military # breaks the log transform, produces -Inf
      military <= 0 ~ NA_real_, TRUE ~ military # friendlier to log-transform, but throws out data
    )
  )
ds2 %>% glimpse()

income_vars <- c(
  "total"            = "Total revenue amount" # sum of all tax codes     
  # Total revenue can be broken into (1) that generated by the hromada (income_own)
  # and (2) that provided by the central government (income_transfert)
  ,"own"              = "Revenue from OWN sources"# = income_total - income_transfert   
  ,"transfert"        = "Revenue from transferts"                                                  
  # in turn, "income_own" can be broken down into components: 
  ,"pdfo"             = "Own: income tax"                                                 
  ,"military"         = "Own: military salaries"                           
  ,"unified"          = "Own: unified tax"                                                
  ,"property"         = "Own: property tax"                                               
  ,"excise"           = "Own: excise duty"                                                
  ,"other"            = "Own: other sources" # income_own - sum(military,pdfo,unified,property,excise)                                                
)

income_vars_pca <- income_vars[c(2,4:9)]

ds2 %>% select(-itemized) %>% readr::write_rds("./data-private/derived/study-pca-ds2.rds")

# ---- outliers-1 ----------------------------------------------

ds2 %>% glimpse()
g2a <- 
  ds2 %>% 
  mutate(
    hromada_code = factor(hromada_code) %>% fct_reorder(total)
    # are these sensible cut-offs? 
    ,outlier_total = case_when(
      total  >= 3000000 ~ "3m+"
      ,total < 3000000 & total > 1000000 ~ "1-3m"
      ,total <= 1000000 & total > 0 ~ "<1m"
    )  %>% factor() %>% fct_rev()
  ) %>% 
  ggplot(aes(x=total, y = hromada_code, color = outlier_total))+
  geom_point()+
  scale_x_continuous(breaks = seq(0,8000000, 500000))+
  theme(
    axis.text.y = element_blank()
  )
 
g2a <-
 ds2 %>% select(-itemized) %>% 
  pivot_longer(cols = setdiff(names(.),c("hromada_code","total"))) %>% 
  mutate(
    name=factor(name,levels = income_vars[-1] %>% names()
                ,labels = income_vars[-1])
    ,outlier_total = case_when(
      total  >= 3000000 ~ "3m+"
      ,total < 3000000 & total > 1000000 ~ "1-3m"
      ,total <= 1000000 & total > 0 ~ "<1m"
    )  %>% factor() %>% fct_rev()
  ) %>%
  ggplot(aes(x=value, y = total, color = outlier_total))+
  geom_point(shape=21, size = 2 )+
  facet_wrap("name", scales = "free")+
  labs(
    title = "Co-Relation of Itemized Revenue with Total Revenue"
    ,subtite = "Outliers"
  )

g2a %>% quick_save("_outliers-total",w=16/1.3,h=9/1.3)

# hromada outliers 
with_total_over_3m <- ds2 %>% filter(total>=3000000) %>% pull(hromada_code)
with_total_btw_1_3m <- ds2 %>% filter(total<3000000&total>1000000) %>% pull(hromada_code)
with_total_over_1m <- ds2 %>% filter(total>=1000000) %>% pull(hromada_code)

# ---- tweak-data-3 -----------------------------------

ds_input <- 
  ds2 %>%
  select(-itemized) %>% 
  filter(hromada_code %ni% with_total_over_3m)

# create alternative metrics to study the decomposition solutions  
# we transform ALL variable, even those that a product of adding up others
# to study they relationship with components and their behavior in PCA
ls3 <- 
  list(
    "raw" = ds_input #%>% 
      # rename_with(~str_c(.,"_raw"),  setdiff(names(.),"hromada_code"))

    ,"z" = # normalized to have a mean = 0 and sd = 1
      ds_input %>% 
      mutate(
        across(
          .cols = setdiff(names(.),"hromada_code")
          ,.fns = ~ (. - mean(., na.rm = T))/sd(.,na.rm = T)
        )
      ) #%>% 
      # rename_with(~str_c(.,"_z"),  setdiff(names(.),"hromada_code"))
   
    ,"r" = # normalized to have values between 0 and 1
      ds_input %>% 
      mutate(
        across(
          .cols = setdiff(names(.),"hromada_code")
          ,.fns = ~scales::rescale(.,to = c(0,1))
        )
      ) #%>% 
      # rename_with(~str_c(.,"_r"),  setdiff(names(.),"hromada_code"))
    
    ,"log" = # log-transformation
      ds_input %>% 
      mutate(
        across(
          .cols = setdiff(names(.),"hromada_code")
          ,.fns = ~log(.)
        )
      ) #%>% 
      # rename_with(~str_c(.,"_log"),  setdiff(names(.),"hromada_code"))
    
    ,"log_z" = # z-score of the log-transform
      ds_input %>% 
      mutate(
        across(
          .cols = setdiff(names(.),"hromada_code")
          ,.fns = ~log(.)
        )
      ) %>% 
      mutate(
        across(
          .cols = setdiff(names(.),"hromada_code")
          ,.fns = ~ (. - mean(., na.rm = T))/sd(.,na.rm = T)
        )
      ) #%>% 
      # rename_with(~str_c(.,"_log_z"),  setdiff(names(.),"hromada_code"))
    
    ,"log_r" = # r-score of the log-transform
      ds_input %>% 
      mutate(
        across(
          .cols = setdiff(names(.),"hromada_code")
          ,.fns = ~log(.)
        )
      ) %>% 
      mutate(
        across(
          .cols = setdiff(names(.),"hromada_code")
          ,.fns = ~scales::rescale(.,to = c(0,1))
        )
      ) #%>%  
      # rename_with(~str_c(.,"_log_r"),  setdiff(names(.),"hromada_code"))
  )
ls3 <- ls3[c("raw","log")]
# ----- univariate-distributions ----------------------------

ds2 %>% glimpse()
list_object <- ls3 # temporary list object

for(i in seq_along(list_object)){
  # i <- 1
  scale_i    <-  names(list_object)[i]
  title_i    <- paste0("Tax Revenue in 2021")
  subtitle_i <- paste0("Scale: ",scale_i)
  path_i     <- paste0("1-univariate-",i,"-",scale_i)
  
  g1 <- 
    list_object[[i]] %>%
    pivot_longer(cols = setdiff(names(.),"hromada_code")) %>% 
    mutate(name=factor(name
                       ,levels = income_vars %>% names()
                       ,labels = income_vars
    )
    ) %>%
    ggplot(aes(x=value))+
    geom_histogram(alpha =.2)+
    facet_wrap("name",scales = "free")+
    labs(
      title = title_i, subtitle =  subtitle_i
    )
  g1 %>% quick_save(path_i,w=8,h=4.5)
  
}
rm(list_object)


# ---- bivariate-distribution ------------------------------
library(GGally)
list_input <- ls3
for(i in seq_along(list_input)){
  # i <- 1
  scale_i    <-  names(list_input)[i]
  title_i    <- paste0("Bivariate distributions of individual variables")
  subtitle_i <- paste0("Scale: ",scale_i)
  
  for(cor_method_i in c("spearman","kendall","pearson")){
    
    path_i     <- paste0("2-bivariate-",i,"-",scale_i,"-",cor_method_i)
    g <- 
      list_input[[i]] %>%
      filter(hromada_code %ni% with_total_over_3m) %>% 
      GGally::ggpairs(
        columns = setdiff(names(.),"hromada_code")
        ,upper = list(continuous = GGally::wrap("cor", method = cor_method_i))
      )+
      labs(
        title = title_i
        ,subtitle = paste0("Scale: ", scale_i," | correlation = ",cor_method_i)
      )
    g %>% quick_save(path_i,w=16/1.3,h=9/1.3)
  }
}


# ---- pca -----------------------------------------------

library(FactoMineR)
library(factoextra)
m1 <- FactoMineR::PCA(ls3[["raw"]] %>% select(-hromada_code))
m1 %>% factoextra::fviz_eig()

list_input <- ls3
list_output <- list()
for(i in seq_along(list_input)){
  # i <- 1
  i_name <- names(list_input)[i]
  list_output[[i_name]][["data"]] <- list_input[[i]]
  list_output[[i_name]][["pca"]] <- list_input[[i]] %>%  select(-hromada_code,-own, -total) %>% FactoMineR::PCA(graph = FALSE)
  list_output[[i_name]][["data_pca"]] <- 
    list_input[[i]] %>% 
    bind_cols(
      "pca1" = (list_output[[i_name]][["pca"]] %>% factoextra::get_pca_ind())$dist # I was trying to extract person score with only first PCA kept, I don't think this is it. 
    ) %>% 
    relocate(pca1)
}
ls4 <- list_output; rm(list_output)

ls4$raw$pca %>% factoextra::fviz_eig(addlabels = TRUE) # better
ls4$log$pca %>% factoextra::fviz_eig(addlabels = TRUE)

ls4$raw$pca %>% factoextra::fviz_pca_var()
ls4$log$pca %>% factoextra::fviz_pca_var()


var <- ls4$raw$pca %>% factoextra::get_pca_var() 

var$cos2 %>% corrplot::corrplot()

(ls4$raw$pca %>% factoextra::get_pca_var() )$cos2 %>% corrplot::corrplot()
(ls4$log$pca %>% factoextra::get_pca_var() )$cos2 %>% corrplot::corrplot()



ls4$raw$pca %>% factoextra::fviz_cos2(choice = "var", axes = 1)

fviz_cos2(res.pca, choice = "var", axes = 1:2)

# ---- bivariate-distribution-2 ------------------------------

# Re-create the bivariate distributions after adding the first component
list_input <- ls4
for(i in seq_along(list_input)){
  scale_i    <-  names(list_input)[i]
  title_i    <- paste0("Bivariate distributions of individual variables")
  subtitle_i <- paste0("Scale: ",scale_i)
  
  for(cor_method_i in c("spearman","kendall","pearson")){
    
    path_i     <- paste0("3-bivariate-",i,"-",scale_i,"-",cor_method_i)
    g <- 
      list_input[[i]][["data_pca"]] %>%
      select(-hromada_code) %>% 
      GGally::ggpairs(
        upper = list(continuous = GGally::wrap("cor", method = cor_method_i))
      )+
      labs(
        title = title_i
        ,subtitle = paste0("Scale: ", scale_i," | correlation = ",cor_method_i)
      )
    g %>% quick_save(path_i,w=16/1.3,h=9/1.3)
  }
  
}
# ---- bivariate-distribution-3 ------------------------------

for(i in seq_along(ls2)){
  # i <- 1
  scale_i    <-  names(ls2)[i]
  title_i    <- paste0("Bivariate distributions of individual variables with PCA1 added")
  subtitle_i <- paste0("Scale: ",scale_i)
  path_i     <- paste0("4-bivariate-",i,"-",scale_i)
  
  g2 <- 
    ls2[[i]][["data_pca"]] %>%
    select(-hromada_code) %>% 
    mutate(
      pca1 = (pca1 - mean(pca1, na.rm = T))/sd(pca1,na.rm = T)
    ) %>% 
    rename(pca1_z = pca1) %>% 
    GGally::ggpairs(
      upper = list(continuous = "cor")
    )+
    labs(
      title = title_i
      ,subtitle = paste0("Scale: ", scale_i)
    )
  
  g2 %>% quick_save(path_i,w=16/1.3,h=9/1.3)
  
}


# ---- pca-review ------------------------




# ------------- -------------------------
ls1$raw
ls1$log
ds0 %>% glimpse()  
  
ds1 <- 
  ds_general %>% 
  # filter(!(hromada_code %in% looks_fishy)) %>% 
  # filter( income_total_2021 < 3000000) %>% 
  mutate(
    income_military_2021  = case_when(
      # income_military_2021 <= 0 ~ 0, TRUE ~ income_military_2021
      income_military_2021 <= 0 ~ NA_real_, TRUE ~ income_military_2021
    )
  ) %>% 
  select(income_total_2021:income_own_2021) %>% 
  select(-income_military_2021)

ds1_log <- 
  ds1 %>% 
  mutate(
    across(
      .cols = everything()
      ,.fns = ~log(.)
    )
  ) %>% 
  rename_with(~str_c(.,"_log"), everything())

ds1_log_norm <- 
  ds1_log %>%
  as.data.frame() %>% 
  scale() %>% 
  as_tibble()


ds1 %>% glimpse()
ds1_log %>% glimpse()
ds1_log_norm %>% glimpse()


# univariate distributions 
g1 <- 
  ds1 %>%
  pivot_longer(cols = everything()) %>% 
  ggplot(aes(x=value))+
  geom_histogram(alpha =.2)+
  facet_wrap("name",scales = "free")

g1 %>% quick_save("pca-1-univariate",w=8, h=4.5)
  
g1 <- 
  ds1_log %>%
  pivot_longer(cols = everything()) %>% 
  ggplot(aes(x=value))+
  geom_histogram(alpha =.2)+
  facet_wrap("name",scales = "free")
g1
g1 %>% quick_save("pca-1-univariate-log",w=8, h=4.5)

g1 <- 
  ds1_log_norm %>%
  pivot_longer(cols = everything()) %>% 
  ggplot(aes(x=value))+
  geom_histogram(alpha =.2)+
  facet_wrap("name",scales = "fixedf")
g1
g1 %>% quick_save("pca-1-univariate-log-norm",w=8, h=4.5)


# bivariate distributions  
g2 <- 
  ds1%>% 
  GGally::ggpairs()
g2 %>% quick_save("pca-2-bivariate", w=16,h=9)

g2 <- 
  ds1_log %>% 
  GGally::ggpairs()
g2 %>% quick_save("pca-2-bivariate-log", w=16,h=9)
g2 <- 
  ds1_log_norm %>% 
  GGally::ggpairs()
g2 %>% quick_save("pca-2-bivariate-log-norm", w=16,h=9)



# ---- pca -----

pca          <- FactoMineR::PCA(ds1)
pca_log      <- FactoMineR::PCA(ds1_log)
pca_log_norm <- FactoMineR::PCA(ds1_log_norm)
pca_log_norm %>% factoextra::fviz_eig()


ds2_log_norm <-
  ds1_log_norm %>% 
  bind_cols("pca" = get_pca_ind(m1)$dist) %>% 
  relocate(pca)

g3 <- 
  ds2_log %>% 
  GGally::ggpairs()
g3 %>% quick_save("pca-3-bivariate-log-norm", w=16,h=9)


library(FactoMineR)
library(factoextra)
m1 <- FactoMineR::PCA(ds1_log)
m1 %>% factoextra::fviz_eig()
ds2_log <-
  ds1_log %>% 
  bind_cols("pca" = get_pca_ind(m1)$dist) %>% 
  relocate(pca)
ds2_log %>% glimpse()

g3 <- 
  ds2_log %>% 
  GGally::ggpairs()
g3 %>% quick_save("pca-3-bivariate-log", w=16,h=9)

m1 <- FactoMineR::PCA(ds1)
m1 %>% factoextra::fviz_eig()
ds2 <-
  ds1 %>% 
  mutate(
    across(
      .cols = everything()
      ,.fns = ~log(.)
    )
  ) %>% 
  rename_with(~str_c(.,"_log"), everything()) %>% 
  bind_cols("pca" = get_pca_ind(m1)$dist) %>% 
  relocate(pca)
ds2 %>% glimpse()

g3 <- 
  ds2 %>% 
  GGally::ggpairs()
g3 %>% quick_save("pca-3-bivariate", w=16,h=9)


(get_pca_ind(m1)$dist )%>% ggplot(aes)










